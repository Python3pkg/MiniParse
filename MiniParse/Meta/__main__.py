#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright 2013 Vincent Jacques
# vincent@vincent-jacques.net

# This file is part of MiniParse. http://jacquev6.github.com/MiniParse

# MiniParse is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

# MiniParse is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.

# You should have received a copy of the GNU Lesser General Public License along with MiniParse.  If not, see <http://www.gnu.org/licenses/>.

import sys
import pipes  # For pipes.quote: see http://stackoverflow.com/questions/4748344/whats-the-reverse-of-shlex-split
import InteractiveCommandLine as ICL

import Grammars.HandWrittenEbnf


class Generate(ICL.Command):
    def __init__(self, prog):
        ICL.Command.__init__(self, "generate", "Generate a MiniParse parser for the input grammar")
        self.__prog = prog
        self.outputName = None
        self.addOption(ICL.StoringOption("out", "Output file", self, "outputName", ICL.ValueFromOneArgument("NAME")))
        self.computeParserName = lambda n: "".join(w[0].upper() + w[1:] for w in n.split(' ')) + "Parser"
        self.addOption(ICL.StoringOption("parser-name-lambda", "Function to generate the names of parser classes", self, "computeParserName", ICL.ValueFromOneArgument("NAME", eval)))
        self.computeMatchName = lambda n: "lambda x: x"
        self.addOption(ICL.StoringOption("match-name-lambda", "Function to generate the names of 'match' arguments", self, "computeMatchName", ICL.ValueFromOneArgument("NAME", eval)))
        self.imports = []
        self.addOption(ICL.AppendingOption("import", "Module to import in generated code", self.imports, ICL.ValueFromOneArgument("MODULE")))

    def execute(self):
        inputName, g = self.__prog.input
        if self.outputName is None:
            self.outputName = inputName[:-5] + ".py"
        with open(self.outputName, "w") as f:
            f.write("# This file was generated by MiniParse.Meta. Manual modifications will likely be lost.\n")
            f.write("# Command line:\n#     python -m MiniParse.Meta " + " ".join(pipes.quote(a) for a in sys.argv[1:]) + "\n")
            f.write("\n")
            for i in self.imports:
                f.write("import " + i + "\n")
            f.write(g.generateMiniParser(self.computeParserName, self.computeMatchName))


class Program(ICL.Program):
    def __init__(self):
        ICL.Program.__init__(self, "python -m MiniParse.Meta")
        self.addOption(ICL.StoringOption("in", "Input file", self, "input", ICL.ValueFromOneArgument("NAME", self.__parseGrammarFile)))
        self.addCommand(Generate(self))

    def __parseGrammarFile(self, input):
        with open(input) as f:
            return (input, Grammars.HandWrittenEbnf.parse(f.read()))


Program().execute()
